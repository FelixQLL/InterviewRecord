# 什么是进程（Process）
**进程**是操作系统中最基本的并发执行单位。每个进程都有自己独立的内存空间，包含代码、数据、文件描述符等资源。
  - 进程拥有代码和打开的文件资源、数据资源、独立的内存空间
  - 进程是**操作系统进行资源分配和调度的基本单位**
  - 进程有五种状态：创建、就绪、阻塞、运行、关闭，五种状态的转换关系图为：
    ![image](https://github.com/FelixQLL/InterviewRecord/assets/28554261/78ce4860-1c2e-4afc-9034-11f804f82408)

# 进程间通信方式
1. 管道：半双工；数据只能单向流动，只能用于具有亲缘关系的进程之间，即用于父子、兄弟之间。
2. 命名管道（FIFO）：半双工，允许无亲缘关系的进程
3. 消息队列：消息链表存于内核，每个消息队列由消息队列标识符标识；于管道不同的是，消息队列存放在内核中，只有在内核重启时才能删除一个消息队列；消息队列的大小受限制。
4. 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对于共享资源的访问。作为一种锁机制，防止某进程正在访问共享资源师，其他进程也访问该资源，常用来处理临界资源的访问同步问题。
   临界资源：为某一时刻只能由一个进程或线程操作的资源。
5. 共享内存：就是映射一段能被其他进程所访问的内存，这段内存由一个进程创建，但可以多个进程同时访问，可以说是最有用的进程间通信方式，也是最快的IPC形式。常与其他通讯机制（信号量）配合使用。
6. 套接字（Socket）：适用于本地和网络通信，提供了强大的双向通信能力，也可用于不同机器之间。
7. 信号（Signal）：比较复杂，用于通知接收进程某个事件已经发生

# 什么是线程（Thread）
**线程**是进程中的一个执行单元，一个进程可以包含多个线程。线程共享进程的内存空间和资源，因此线程之间的通信相对简单，但也容易引发并发问题，如数据竞争。
  - 线程拥有自己的栈空间
  - 它可与同属一个进程的其他的线程**共享**进程所拥有的全部资源
  - 线程是最小的执行单元
  - 无论进程还是线程，都是由操作系统所管理的

# 线程同步的方式
1. **互斥锁（Mutex）：** 提供了以排他方式防止数据结构被并发修改的方法，互斥对象和临界区对象非常相似，只是其允许在进程间使用，也可在线程间使用，而临界区只限制与同一进程的各个线程之间使用。
2. **条件变量（Condition Variable）**：以原子的方式阻塞进程，直到某个特定条件为真为止，一个线程被挂起，直到某件事件发生。条件变量始终与互斥锁一起使用。
3. **信号量（semaphore）：** 信号量是一种更复杂的同步原语，它可以用来控制多个线程对共享资源的访问。信号量维护一个计数器，表示可用资源的数量，线程可以通过信号量进行等待或释放。mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。
``` C++
#include <semaphore.h>

sem_t semaphore;

void thread1() {
    sem_wait(&semaphore); // 等待信号量
    // 访问共享资源
    sem_post(&semaphore); // 释放信号量
}

void thread2() {
    sem_post(&semaphore); // 发送信号量
}
```  
4. 原子操作

# 什么是协程（Coroutine）
**协程**是一种更轻量级的并发机制，可以在单线程中实现类似多线程的并发效果。一个线程可以拥有多个协程。
**协程**是一种可以暂停和恢复执行的函数。

# 协程的上下文切换
**步骤：**
1. 保存当前执行上下文：保存当前寄存器和堆栈指针
2. 加载目标执行上下文
3. 切换到目标上下文

# 进程与线程区别
1. **内存分配**：
   - 进程：每个进程有自己独立的地址空间，一个进程崩溃后，在保护模式下不会影响其他进程。
   - 线程：所有线程共享其母进程的地址空间，一个线程的错误可能会导致整个进程的崩溃。
2. **通信方式**：
   - 进程：进程间通信需要特殊的IPC机制。
   - 线程：线程间可以直接读写进程数据段（如全局变量）来进行通信。
3. **系统开销**：
   - 进程：进程在创建、销毁、切换时的系统开销大，因为涉及到对应的地址空间的创建和销毁。
   - 线程：线程的创建、销毁、切换的开销相对较小，因为它们共享很多资源。
4. **资源管理**：
   - 进程：作为资源分配的基本单位，独立进程拥有完整资源集合。
   - 线程：作为调度执行的基本单位，只维护必要的信息和资源供运行。
5. **依赖关系**：
   - 进程：进程可以独立执行，不依赖其他进程。
   - 线程：线程是进程的一部分，依赖于进程的存在。
6. **执行环境**：
   - 进程：每个进程提供给其内部线程的执行环境相对复杂。
   - 线程：线程拥有较为简单的执行环境。

# 协程和线程的区别
![image](https://github.com/FelixQLL/InterviewRecord/assets/28554261/64382068-c123-4b97-aeb5-953fdc3f80c6)


# ROS 通信机制
参考：https://blog.csdn.net/qq_66257231/article/details/125023331

1. **Ros Topic：**
   - 异步通信：发布者和订阅者独立运行，不需要彼此等待。
   - 多对多通信：一个 topic 可以有多个发布者和多个订阅者。
   - 消息中介：在ROS中，ROS Master管理各个节点的注册信息，确保发布者和订阅者能够找到彼此，但消息的实际传递由点对点（peer-to-peer）连接完成。
2. **Ros Service：**
   - 同步通信：客户端发送请求后等待服务端的响应，客户端和服务端之间存在同步等待关系。
   - 一对一通信：每个服务只有一个提供者（服务端），但可以有多个请求者（客户端）。
   - 直接连接：客户端和服务端之间建立直接的连接来传递请求和响应。
3. **Ros Param：**
   - 集中式存储：参数服务器集中存储所有参数，允许各个节点访问。
   - 键值对存储：参数以键值对的形式存储，每个参数都有一个唯一的键。
   - 支持多种数据类型：参数可以是整数、浮点数、字符串、布尔值、列表和字典等。
   - 生命周期与 ROS Master 一致：参数服务器与 ROS Master 共享生命周期，当 ROS Master 关闭时，参数服务器也会关闭。
##### 总结：
ROS通信基于TCP/UDP，ROS Param 不涉及TCP/UDP通信

# ROS Topic 和 Service的区别
![image](https://github.com/FelixQLL/InterviewRecord/assets/28554261/177778ce-081a-4040-9d28-c055d5e9f83d)

# TCP/UDP 区别
![image](https://github.com/FelixQLL/InterviewRecord/assets/28554261/899eb879-ebf8-4810-8796-05aa1d4d621f)

