# C++编译过程：
预处理（宏，头文件）->编译（语法分析，语法树生成，优化，生成汇编代码）->汇编（汇编代码转机器代码，二进制）->链接（符号解析，符合重定位，库的处理，生成可执行文件）->执行

# C++链接过程：
链接器将一个或多个目标文件与库文件结合在一起，生成最终的可执行文件
·  符号解析：链接器解析各个目标文件中的符号（函数和变量），确保所有符号都有定义。
·  符号重定位：将目标文件中的相对地址转换为绝对地址。
·  库的处理：链接静态库或动态库，以满足程序对外部符号的需求。
·  生成可执行文件：将所有目标文件和库文件组合起来，生成最终的可执行文件。

# 面向对象的三大特征是什么
面向对象编程的三大特征是：封装、继承和多态。
1. 封装（Encapsulation）：封装是把数据（变量）和操作数据的函数结合在一起，形成一个“对象”。这个数据类型的内部实现细节可以被隐藏起来，只暴露必要的接口给外部使用。封装可以提高代码的重用性，改善程序设计的可维护性。
2. 继承（Inheritance）：继承是子类自动共享父类数据结构和方法的机制，这使得子类对象可以达到父类对象的所有属性和行为。子类还可以添加自己的新的属性和行为。这种特性有助于减少代码重复，并且可以提高代码的可维护性和复用性。
3. 多态（Polymorphism）：多态意味着调用哪个对象的哪个方法，取决于运行时该对象所属的类。多态可以提高代码的灵活性和可扩展性。在C++中，多态通常通过虚函数实现。

# const 作用
1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

# const函数内如何修改变量
1. mutable 关键字可以用于数据成员，使得即使在 const 成员函数中也可以修改这些成员变量。
2. const_cast 类型转换来移除 const 限制。然而，这种做法通常被认为是不安全的，应尽量避免。

# const char* 和char* const区别
const char* ptr ，表示指向的是一个常量字符数据，换句话说，通过这个指针不能修改所指向的字符数据。指针本身是可以改变的，也就是说，可以使它指向不同的字符数据。
``` C++
const char* ptr = "Hello";
ptr = "World";  // 这是可以的，因为指针本身可以修改
// *ptr = 'H';  // 这是不可以的，因为指向的内容是const
```
char* const 表示指针本身是常量，不能改变，但指针指向的内容是可以修改的。
```
char text[] = "Hello";
char* const ptr = text;
ptr[0] = 'h';  // 这是可以的，因为指向的内容可以修改
// ptr = "World";  // 这是不可以的，因为指针本身是const
```

# define和const的区别有那些？
1. 作用域不同：
   - \#define定义的常量是一个预处理宏，它在编译之前被替换，作用域为定义处到文件结束。
   - const定义的常量是一个真正的变量，其作用域根据定义的位置而定，可以是局部或全局作用域。
2. 类型安全性：
   - \#define不具有类型检查，在预处理阶段只是简单地进行文本替换，容易导致一些潜在的错误。
   - const定义的常量具有类型检查，编译器会对其进行类型检查，提供更好的类型安全性。
3. 调试信息：
   - \#define在预处理阶段进行文本替换，因此在调试时无法查看使用#define定义的常量的值。
   - const定义的常量是真正的变量，可以被调试器识别并显示其值。
     
![image](https://github.com/FelixQLL/InterviewRecord/assets/28554261/521149c2-2c9e-4a5e-abb5-e1380995c859)

# static 作用
1. 静态局部变量：当 static 用于函数内部的局部变量时，该变量在函数调用结束后仍然存在，而不是每次调用时重新创建。它在程序的整个生命周期内保持存在，并且仅在第一次调用函数时初始化。
``` C++
   void exampleFunction() {
    static int count = 0;
    count++;
    std::cout << "Count is " << count << std::endl;
}

int main() {
    exampleFunction(); // 输出 Count is 1
    exampleFunction(); // 输出 Count is 2
    exampleFunction(); // 输出 Count is 3
    return 0;
}
```
2. 静态全局变量：在文件范围内声明的静态全局变量只在定义它的文件中可见。这种用法用于限制变量的作用域，以避免命名冲突。
``` C++
// file1.cpp
static int counter = 0;

// file2.cpp
// static int counter = 0; // file2.cpp中独立的static变量
```
3. 静态成员变量：在类中声明的静态成员变量属于类本身，而不是属于某个对象的实例。它们在所有对象实例之间共享。静态成员变量需要在类外进行定义。
``` C++
class MyClass {
public:
    static int count;
};

int MyClass::count = 0;

int main() {
    MyClass obj1;
    MyClass obj2;
    MyClass::count = 1; // 所有对象共享同一个count
    std::cout << MyClass::count << std::endl; // 输出 1
    return 0;
}
```
4. 静态成员函数：静态成员函数属于类本身，可以在不创建类对象的情况下调用。**它们不能访问非静态成员变量**，因为非静态成员变量属于类的实例，而静态成员函数不属于任何实例。
``` C++
class MyClass {
public:
    static void display() {
        std::cout << "Static member function" << std::endl;
    }
};

int main() {
    MyClass::display(); // 调用静态成员函数
    return 0;
}
```
5. 静态成员函数与静态成员变量结合使用：静态成员函数通常用于操作静态成员变量。

# extern 作用
它告诉编译器，这个变量或函数的定义在别的地方，你不必在当前文件中定义它。
**变量声明：**
``` C++
// file1.cpp
int myVar = 10;

// file2.cpp
extern int myVar;
void func() {
    std::cout << myVar << std::endl; // 访问 file1.cpp 中的 myVar
}
```
**函数声明：**
``` C++
// file1.cpp
void myFunction();

// file2.cpp
void myFunction() {
    std::cout << "Hello from myFunction" << std::endl;
}
```
file1 和 file2同时定义 myVar，再使用extern myVar时，会**链接错误**

# C++中struct和class有什么区别？
1. 默认的访问权限：
   - 在struct中，默认的成员变量和成员函数的访问权限是public的，意味着它们可以被外部访问。
   - 在class中，默认的成员变量和成员函数的访问权限是private的，意味着它们只能够在类的内部访问。
2. 继承方式：
   - 在struct中，继承的默认访问权限是public的，派生类可以访问基类的public和protected成员。
   - 在class中，继承的默认访问权限是private的，派生类可以访问基类的public和protected成员。

# C++中动态链接库和静态连接库的区别是什么？
### 1. 链接时期

- **静态链接库**：在程序编译时，静态库的内容会被复制到最终的可执行文件中。当你运行程序时，不需要库文件，因为所有的功能都已经包含在可执行文件里了。
- **动态链接库**：程序在编译时并不复制库中的代码，而是在程序运行时加载库文件。这意味着库文件必须在程序运行时可用。

### 2. 文件大小

- **静态链接库**通常会导致较大的可执行文件大小，因为所有使用的库代码都被复制进去了。
- **动态链接库**允许可执行文件小一些，因为代码是在运行时才被加载。

### 3. 内存占用

- **静态链接库**的缺点是如果有多个程序使用相同的库，每个程序都有自己的副本，这将导致内存的浪费。
- **动态链接库**可以由多个正在运行的程序共享，只需在内存中有一个副本即可。

### 4. 分发和更新

- **静态链接库**使得更新库变得复杂，因为每个应用都有自己的副本，所以每个应用都需要重新编译和分发。
- 使用**动态链接库**时，只需替换库文件并且确保API兼容性，所有使用该库的应用程序就可以直接利用新版本的库，无须重新编译。

### 5. 跨平台兼容性

- **静态链接库**生成的可执行文件更易于在没有安装相应库的不同系统上运行，因为它们包括了所有需要的代码。
- 对于**动态链接库**，需要确保目标系统上存在正确版本的库文件。

### 6. 链接错误和冲突

- **静态链接库**可能会引起版本冲突问题，尤其是当不同的库依赖同一个库但又各自静态链接了不同版本时。
- **动态链接库**可以减少这种冲突，因为同一份库文件被所有依赖它的程序共享。

# 什么是左值？什么是右值？有什么不同？
### 左值 (Lvalue):

一个**左值**是指有地址的对象，可以出现在赋值运算符的左边。简单地说，左值是可以持久存在的内存对象。常见的左值包括变量、数组元素、结构体成员等。

### 右值 (Rvalue):

一个**右值**是指没有持久内存地址的对象，通常是临时值，不能取地址。右值常常用于表达式的计算结果或字面常量。

**不同点：**

- **身份**: 左值具有明确的内存地址，而右值通常没有固定的内存地址。
- **持久性**: 左值代表长期存在的对象，右值代表临时或即将销毁的对象。
- **可移动性**: 右值可以被移动，而左值通常不能，除非显式地转换成右值引用。
- **引用类型**: 可以声明左值引用指向左值（`T&`），而右值引用(`T&&`)可以绑定到右值上，优化资源使用。

# C++中右值引用有什么作用？
C++11引入了右值引用，用来支持移动语义和完美转发。

1. 移动语义：传统的复制操作需要额外的时间和空间，而有了移动语义后，可以直接将资源（如内存）从一个对象转移到另一个对象，而不必创建并删除临时对象。这对于大对象或者拥有独占所有权资源的对象特别有用。例如，unique_ptr和std::vector等STL容器就利用了移动语义实现了高效的操作。
2. 完美转发：在函数模板中，我们想把参数原封不动地传递给其他函数。由于传参可能存在值传递、左值引用、常量左值引用、右值引用等情况，为了保证参数的属性和类型不发生变化，我们需要使用std::forward实现完美转发。

右值引用主要用于两种场景：一是对象的移动（Move），二是万能引用（Forwarding Reference）。对于第一种情况，它是为了解决对象的复制效率问题；对于第二种情况，则是为了实现参数的完美传递，避免不必要的拷贝。

# explicit（显式）关键字
1. explicit 修饰构造函数时，可以防止隐式转换和复制初始化
2. explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外
##### 什么时候会有隐式转换
构造函数 基本数据类型之间的转换
``` C++
struct A
{
	A(int) { }
	operator bool() const { return true; }
};

struct B
{
	explicit B(int) {}
	explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
	A a1(1);		// OK：直接初始化
	A a2 = 1;		// OK：复制初始化
	A a3{ 1 };		// OK：直接列表初始化
	A a4 = { 1 };		// OK：复制列表初始化
	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
	doA(1);			// OK：允许从 int 到 A 的隐式转换
	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a6(a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

	B b1(1);		// OK：直接初始化
	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
	B b3{ 1 };		// OK：直接列表初始化
	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

	return 0;
}
```

# C++中四种cast的转换？
1. **static_cast**： `static_cast` 是用于编译时检测到的相关类型之间的转换，比如整型和浮点数、派生类和基类之间的指针或引用转换。它不能用于含有虚函数的多态基类指针或引用到派生类的转换，因为这需要运行时信息。
   - 用于非多态类型的转换
   - 不执行运行时类型检查（转换安全性不如 dynamic_cast）
   - 通常用于转换数值数据类型（如 float -> int）
   - 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）
     
   示例：
   ``` C++
   int i = 10;
   float f = static_cast<float>(i);    // 整型到浮点数的转换
   ```
2. **dynamic_cast**： `dynamic_cast` 主要用于处理多态性。当涉及到继承体系中的向下转换（将基类的指针或引用转换为派生类类型）时，这个转换会检查转换的安全性。如果转换无效，对于指针，它会返回nullptr；对于引用，则抛出一个`std::bad_cast`异常。使用`dynamic_cast`需要运行时类型信息（RTTI），因此它有一定的性能代价。
   - 用于多态类型的转换
   - 执行行运行时类型检查
   - 只适用于指针或引用
   - 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
   - 可以在整个类层次结构中移动指针，包括向上转换、向下转换
   
   示例：
   ``` C++
   Base* b = new Derived();   // 基类指针指向派生类对象
   Derived* d = dynamic_cast<Derived*>(b);   // 向下转型成功
   if (d) {
       // 转型有效，'d' 不是 nullptr
   }
   ```
4. **const_cast**： `const_cast` 用于移除或添加`const`或`volatile`属性。通常情况下，它被用于移除对象的常量性，允许修改原本被声明为`const`的变量。需要注意的是，去除一个本质上确实是常量的对象的`const`标记并进行修改可能会导致未定义行为。
   - 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）

   示例：
   ``` C++
   const int ci = 10;
   int& modifiable = const_cast<int&>(ci);   // 移除常量性以便修改
   modifiable = 20;  // 注意：如果原对象真的是const，这里可能是未定义行为
   ```
6. **reinterpret_cast**： `reinterpret_cast` 是最危险的cast，它能够执行低级的强制类型转换。尽管几乎没有任何语义检查，但它能够在几乎任意两种类型之间转换，例如整数与指针之间的转换。由于它的不安全性，应该尽可能避免使用`reinterpret_cast`，除非你完全理解所进行的转换。
   - 用于位的简单重新解释
   - 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
   - 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全）
   - 也允许将任何整数类型转换为任何指针类型以及反向转换。
   - reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。
   - reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

   示例：
   ``` C++
   int* p = new int(65);
   char* ch = reinterpret_cast<char*>(p);  // 强制指针类型转换
   ```

总结：
- `static_cast`在相关类型间做安全转换。
- `dynamic_cast`在类层次结构中转换，并支持运行时检查。
- `const_cast`改变类型的`const`或`volatile`限定。
- `reinterpret_cast`进行低级别、不安全的强制类型转换。

# 友元类和友元函数
友元类和友元函数允许一个类授予另一个类或函数访问其私有和受保护成员的权限。
 - 能访问私有成员
 - 破坏封装性
 - 友元关系不可传递
 - 友元关系的单向性：被声明为友元的一方可以访问声明方的私有和受保护成员，但这种访问权限并不会自动反向授予
 - 友元声明的形式及数量不受限制

# enum class 和enum的区别
1. **作用域：**
   - **enum class:** 枚举成员是枚举类的作用域内的。在使用时需要指定枚举类型的名称。
   - **enum:** 枚举成员是在包含它们的作用域内的，可以直接使用枚举成员的名称。
``` C++
enum class Color { Red, Green, Blue };
enum Direction { North, South, East, West };

int main() {
    Color c = Color::Red; // 需要指定 Color
    Direction d = North;  // 可以直接使用 North

    return 0;
}
```
2. **类型安全性:**
   - **enum class:** 枚举类型是强类型的。不能隐式转换为整数，也不能隐式转换为其他枚举类型。这提供了更好的类型安全性。
   - **enum:** 枚举类型是弱类型的。可以隐式转换为整数，可以与整数和其他枚举类型进行比较。
``` C++
enum class Color { Red, Green, Blue };
enum Direction { North, South, East, West };

int main() {
    Color c = Color::Red;
    // int colorValue = c; // 错误，不能隐式转换为整数
    int colorValue = static_cast<int>(c); // 正确，需要显式转换

    Direction d = North;
    int directionValue = d; // 正确，可以隐式转换为整数

    // if (c == d) {} // 错误，不能比较不同类型的枚举
    if (static_cast<int>(c) == directionValue) {} // 正确，需要显式转换

    return 0;
}
```
3. **默认底层类型：**
   - **enum class:** 默认底层类型是 int，但可以显式指定其他整数类型。
   - **enum:** 默认底层类型是 int，不可显示指定其他类型。
# C++多态的实现有那几种？他们有什么不同？
C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。

1. **编译时多态（静态多态）**: 编译时多态是在程序编译阶段实现的多态性。主要通过函数重载和运算符重载来实现。

   - **函数重载**: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。
   - **运算符重载**: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。

   **编译时多态的决策是在编译时做出的**，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。

2. **运行时多态（动态多态）**: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。

   - **虚函数**: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。
   - **抽象类和纯虚函数**: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。

   **运行时多态的决策是在程序运行时做出的**，这就**需要运行时类型信息和虚函数表（vtable）**。在运行时，根据对象的实际类型来动态调用相应的成员函数，从而实现多态。

总的来说：

- **编译时多态**是静态的，主要通过函数重载和运算符重载来实现，决策发生在编译阶段。
- **运行时多态**是动态的，需要虚函数机制，并且决策发生在程序运行时。
- **运行时多态**能够提供更高的灵活性和扩展性，是实现框架和库中一些高级功能（如插件架构或事件处理系统）的关键。
- **编译时多态**由于在编译期就已经确定了调用哪个函数，通常性能更高，因为它避免了运行时查找虚函数表的开销。

# C++的智能指针及其原理
### 智能指针简介
C++的智能指针是一种用于管理动态分配内存的对象，它们提供了自动内存管理机制，避免了手动释放内存的繁琐和潜在的内存泄漏问题。

智能指针的原理基于RAII原则，即资源获取即初始化。智能指针通过在构造函数中获取资源（动态分配的内存），并在析构函数中释放资源，从而确保资源的正确释放。

C++标准库提供了两种主要的智能指针：`std::unique_ptr`和`std::shared_ptr`。

1. `std::unique_ptr`： `std::unique_ptr`是独占所有权的智能指针，它确保只有一个指针可以访问所管理的对象。当`std::unique_ptr`被销毁时，它会自动释放所拥有的对象。它不能被复制，但可以通过std::move()函数进行所有权转移。
2. `std::shared_ptr`： `std::shared_ptr`是共享所有权的智能指针，它可以被多个指针同时访问和共享所管理的对象。它使用引用计数来追踪有多少个指针指向该对象，当引用计数为0时，即没有任何指针指向对象时，资源会被释放。`std::shared_ptr`可以被复制和赋值。

注意：weak_ptr严格来说，不能算是“智能指针”，他只是一个类的弱引用，是用来解决两个`std::shared_ptr`相互进行引用的问题的

### 侵入式和非侵入式的智能指针

在C++中，智能指针又被分为两种:侵入式和非侵入式的

1. **侵入式智能指针**： 侵入式智能指针需要被管理的类提供特定的接口或继承指定的基类，以支持智能指针的操作。这意味着被管理的类必须拥有与智能指针相关的成员函数或遵循特定的约定。侵入式智能指针可以更好地控制资源的生命周期，但需要修改被管理类的定义。

   例如，Boost库中的`boost::intrusive_ptr`就是一种侵入式智能指针。被管理的类必须实现`add_ref()`和`release()`等函数，以增加和释放引用计数。

2. **非侵入式智能指针**： 非侵入式智能指针不需要被管理的类提供额外的接口或继承特定的基类。它通过自身的机制来管理资源的生命周期，而不需要对被管理的类做任何修改。这样可以更方便地将智能指针应用到已有的类中。

   C++标准库中的`std::shared_ptr`就是一种非侵入式智能指针。它可以管理任何动态分配的对象，而不需要对被管理的类做任何特殊要求。

非侵入式智能指针相对于侵入式智能指针更加灵活和方便，但在某些情况下侵入式智能指针可能提供更细粒度的资源管理控制。选择使用哪种类型的智能指针取决于具体的需求和设计考虑。

# 虚函数、纯虚函数、虚析构、虚继承
## 虚函数和纯虚函数的区别
纯虚函数：
``` C++
virtual int A() = 0;
```
1. **实现多态：**
   - **虚函数：** 用于实现多态，允许基类指针或引用调用派生类的重写函数。
   - **纯虚函数：** 用于定义接口，强制派生类实现该接口，提供一种实现多态的方式。
2. **类的实例化：**
   - **虚函数：** 包含虚函数的类可以实例化。
   - **纯虚函数：** 包含纯虚函数的类是抽象类，不能直接实例化。
3. **函数实现：**
   - **虚函数：** 基类中可以提供一个默认实现，派生类可以选择重写或者不重写。
   - **纯虚函数：** 基类中没有实现，派生类必须提供实现。

## 虚析构函数
**作用：** 当你使用基类指针指向派生类对象，并通过这个指针删除对象时，如果基类的析构函数不是虚的，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致派生类的资源未被正确释放，从而引起资源泄漏或其他未定义行为。

## 虚继承
**菱形继承问题：**
``` C++
class A {
public:
    int x;
};

class B : public A {
};

class C : public A {
};

class D : public B, public C {
};
```
在类 D 中，由于 B 和 C 都继承自 A，而 D 又同时继承自 B 和 C，这种继承关系形成了一个菱形结构。如果 A 类中有一些成员变量或成员函数，那么在 D 类中就会出现两份 A 类的子对象，这种重复可能会引发二义性和资源浪费问题。
**解决方案：虚继承**
虚继承的目的是确保在多重继承中共享基类的实例。通过在继承链中的基类前面加上 virtual 关键字来声明虚继承。例如：
``` C++
class A {
public:
    int x;
};

class B : virtual public A {
};

class C : virtual public A {
};

class D : public B, public C {
};
```
**虚继承的特点:**
1. 共享基类实例：通过虚继承，确保在派生类中共享同一个虚基类的实例，避免了多个实例的重复问题。
2. 虚基类初始化：虚基类的构造函数由最终派生类负责调用，而且只调用一次。
3. 二义性解决：解决菱形继承中的二义性问题，确保派生类能够准确访问到基类成员。

虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

**虚继承与虚函数：**
- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
   - 虚继承
      - 虚基类依旧存在继承类中，只占用存储空间
      - 虚基类表存储的是虚基类相对直接继承类的偏移
   - 虚函数
      - 虚函数不占用存储空间
      - 虚函数表存储的是虚函数地址

# IO模型了解哪些？
1. **阻塞IO模型**（Blocking IO）：
   - 在阻塞IO模型中，当应用程序发起IO操作时，会被阻塞直到数据准备好或者IO完成。
   - 这意味着应用程序在进行IO操作时会暂停执行，直到数据准备好可以读取或写入完成后才会继续执行。
   - 阻塞IO模型简单易用，但可能导致资源浪费和性能下降。
2. **非阻塞IO模型**（Non-blocking IO）：
   - 在非阻塞IO模型中，应用程序发起IO操作后，并不会被阻塞，而是立即返回结果。
   - 应用程序需要通过轮询等方式主动查询IO操作是否完成，从而实现异步IO操作。
   - 非阻塞IO模型相比阻塞IO模型可以提高系统的并发性能。
3. **多路复用IO模型**（I/O multiplexing）：
   - 多路复用IO模型利用操作系统提供的select、poll、epoll等机制同时监控多个文件描述符的IO状态。
   - 当某个文件描述符就绪时，应用程序可以通过事件通知来进行IO操作，避免了阻塞等待。
   - 多路复用IO模型可以有效地管理多个IO操作，提高系统的效率和吞吐量。
4. **信号驱动IO模型**（Signal-driven IO）：
   - 信号驱动IO模型通过向内核注册信号处理函数，在IO操作完成时由内核发送信号来通知应用程序。
   - 应用程序可以继续执行其他任务，而无需阻塞等待IO操作完成。
   - 信号驱动IO模型相对于非阻塞IO模型提供了更好的异步IO支持。
5. **异步IO模型**（Asynchronous IO）：
   - 异步IO模型通过操作系统提供的异步IO接口来实现IO操作，应用程序可以在IO操作完成后得到通知。
   - 应用程序无需关心IO操作的具体状态，可以继续执行其他任务。
   - 异步IO模型适合处理大量的IO请求，提高系统的响应速度和并发处理能力。

# STL中，map的底层是如何实现的？
在C++标准模板库（STL）中，`map` 是一种关联容器，它以键值对的方式存储元素，其中每个键都是唯一的。底层实现通常使用红黑树（Red-Black Tree），这是一种自平衡的二叉搜索树。

红黑树保持了树的平衡性，即从根到所有叶子节点的最长路径不会超过最短路径的两倍。这种性质确保了`map`中的操作（如插入、删除和查找）可以在对数时间复杂度O(log n)内完成。

红黑树有以下特性：

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色。
3. 所有叶子节点（NIL节点，空节点）都是黑色。
4. 每个红色节点必须有两个黑色的子节点（不能有两个连续的红色节点）。
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

因为`map`的底层是红黑树这种高度平衡的数据结构，所以它能够提供良好的性能保证，使得即使在大量元素存储的情况下也能保持效率。

需要注意的是，在C++11后，还引入了`unordered_map`，它使用哈希表作为底层实现，提供平均常数时间复杂度O(1)的访问性能，但它不保证元素的顺序，并且在最坏情况下可能退化为线性时间复杂度O(n)。

# STL中，set的底层是如何实现的？
在C++标准模板库（STL）中，`set` 是基于关联容器的一个抽象数据类型，用于存储不重复的元素。与 `map` 类似，`set` 的底层实现也通常采用红黑树（一种自平衡的二叉搜索树）。这使得 `set` 中的大多数操作（例如插入、删除和搜索）都能以对数时间复杂度 O(log n) 来执行，其中 n 是集合中元素的数量。

使用红黑树作为底层数据结构，`set` 可以保证元素会按照特定的顺序排序，通常是按照键值的递增顺序。红黑树确保了任何时候树都是相对平衡的，所以 `set` 容器在处理大量动态插入和删除操作时依然能够提供良好的性能。

除了 `set`，STL 还提供了 `unordered_set` 容器，其底层实现是基于哈希表。`unordered_set` 不保证元素的有序性，但在理想情况下可以提供更快的平均时间复杂度 O(1) 的访问性能。不过，在最坏的情况下（例如，当哈希函数导致很多碰撞时），它的性能可能会退化到 O(n)。

list和vector有什么区别
vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。 list拥有一段不连续的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。

# 为什么需要虚析构函数,什么时候不需要

一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。

# 为什么需要虚继承

虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。
如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。

虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，

# 虚函数是否可以声明为static？
虚函数不能声明为静态（static）。在C++中，虚函数是通过指针的动态绑定来实现多态性的，而静态成员函数是与类本身相关联的，不依赖于特定对象的实例化，因此无法被继承并重写。

当我们声明一个成员函数为虚函数时，编译器会为每个类维护一个虚函数表（vtable），用于存储该类的虚函数地址。然后，在运行时，通过对象的指针或引用调用虚函数时，程序会根据实际对象类型的虚函数表来确定要调用的函数。

相反，静态成员函数不与任何特定对象实例相关联，它属于类而不属于对象。因此，静态函数没有 this 指针，并且不参与多态性和动态绑定。由于静态成员函数没有虚函数表的概念，因此它们不能被声明为虚函数。

因此，在C++中，虚函数不能声明为静态。

# 什么是进程？什么是线程？他们的区别是什么？
### 进程

一个**进程**是操作系统分配资源的基本单位。它代表了应用或程序的一次执行实例。**每个进程都拥有独立的内存空间、数据栈以及其他用于跟踪执行的辅助数据。**操作系统管理着所有进程，并为它们分配CPU时间。

**进程之间相互隔离，通常情况下，一个进程无法直接访问另一个进程的资源**，这种设计提高了系统稳定性。

### 线程

一个**线程**是操作系统能够进行运算调度的最小单位。**它被包含在进程之中，是进程中的实际运行单位。一个进程可以拥有一个或多个线程，所有线程共享进程的内存和资源。**但是，每个线程还会拥有自己的执行堆栈和程序计数器。

**线程也称为轻量级进程**，因为它们比完整的进程更“轻”，创建和上下文切换的开销较小。

### 进程与线程的区别
1. **内存分配**：
   - 进程：每个进程有自己独立的地址空间，一个进程崩溃后，在保护模式下不会影响其他进程。
   - 线程：所有线程共享其母进程的地址空间，一个线程的错误可能会导致整个进程的崩溃。
2. **通信方式**：
   - 进程：进程间通信需要特殊的IPC机制。
   - 线程：线程间可以直接读写进程数据段（如全局变量）来进行通信。
3. **系统开销**：
   - 进程：进程在创建、销毁、切换时的系统开销大，因为涉及到对应的地址空间的创建和销毁。
   - 线程：线程的创建、销毁、切换的开销相对较小，因为它们共享很多资源。
4. **资源管理**：
   - 进程：作为资源分配的基本单位，独立进程拥有完整资源集合。
   - 线程：作为调度执行的基本单位，只维护必要的信息和资源供运行。
5. **依赖关系**：
   - 进程：进程可以独立执行，不依赖其他进程。
   - 线程：线程是进程的一部分，依赖于进程的存在。
6. **执行环境**：
   - 进程：每个进程提供给其内部线程的执行环境相对复杂。
   - 线程：线程拥有较为简单的执行环境。

# 协程是什么，为什么需要协程
#### 1.协程
本质⽤户空间下的线程
拥有⾃⼰的寄存器上下⽂和栈
切换情况：先将寄存器上下⽂和栈保存，等切换回来的时候再进⾏恢复
**2、原因**

⼀是节省 CPU，避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。⽽协程是⽤户态的线程，⽤户可以⾃⾏控制协程的创建与销毁，极⼤程度避免了系统级线程上下⽂切换造成的资源浪费。

⼆是节约内存，在 64 位的 Linux 中，**⼀个线程**需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约⽆法开启更多线程实现⾼并发。但是协程他的大小只有几十kb ，可以轻松有⼗⼏万协程，这是线程⽆法⽐拟的。

三是稳定性，前⾯提到线程之间通过内存来共享数据，这也导致了⼀个问题，任何⼀个线程出错时，进程中的所有线程都会跟着⼀起崩溃。

四是开发效率，使⽤协程在开发程序之中，可以很⽅便的将⼀些耗时的 IO 操作异步化，例如写⽂件、耗时 IO 请求等。

# 协程与线程的区别
**定义：** 线程是操作系统调度的最小单位；协程是用户级别的轻量级线程；
**负责人：** 线程是操作系统内核负责，协程由用户代码管理
**调度方式：** 线程-抢占式调度，操作系统根据时间片轮转或优先级算法等机制来切换线程的执行；
               协程-协作式调度，协程由用户代码显式控制切换时机；
**栈内存：** 线程-几MB，协程-几KB
**上下文切换开销：** 线程-涉及保存和恢复大量的 CPU 寄存器和缓存状态，几千个CPU周期；
                      协程-只涉及少量寄存器的保存和恢复，100个CPU周期
 **上下文：** 线程-上下文独立；协程-上下文共享，协程共享同一线程的上下文；
 **使用场景：** 线程-CPU 密集型任务；协程-I/O 密集型任务；

# 协程切换的C++底层实现：
1.无论协程怎么被创建，底层都要分配执行栈和控制信息。
2.让出执行权时候,都要保存执行现场，以便后续恢复。
3.每个协程都有自己的执行栈，可以保存自己的执行现场。
4.可以由用户程序按需创建协程。
5.协程“主动让出”执行权时候，会保存执行现场，然后切换到其他协程。
6.协程恢复执行时候会根据之前保存的执行现场恢复到中断前的状态，继续执行，这样就通过协程实现了既轻量又灵活的由用户态调度的多任务模型。

# 同步，异步，阻塞和非阻塞的概念
1. 同步：在同步操作中，调用者会等待操作完成后才返回。例如，在进行磁盘读写或者网络数据传输时，如果使用同步方式，那么在整个读写或者传输过程完成之前，调用者会一直等待。
2. 异步：在异步操作中，调用者发起操作后不会立刻等待结果，而是可以继续做其他事情。当操作完成后，通过某种机制通知调用者。这样，异步操作可以帮助提高程序的并发性和响应性。
3. 阻塞：在阻塞状态下，调用者在等待操作完成期间无法进行其他操作，必须等待当前操作完成后才能继续，它会导致程序暂停执行。
4. 非阻塞：在非阻塞状态下，即使操作还没有完成，调用者也能立即返回，进行其他操作。如果操作未完成，调用者可能需要定期检查操作状态，或者通过某种机制接收操作完成的通知。

这四种概念往往会成对出现，例如“同步阻塞”和“异步非阻塞”。一个典型的例子就是网络编程中的I/O模型，其中包括同步阻塞I/O、同步非阻塞I/O、异步阻塞I/O和异步非阻塞I/O。

# select模型和poll模型epoll模型
下面只是一个简单的介绍，比较适合面试的时候概括：
1. **select模型**：这是最古老的一种IO多路复用模型。它的主要功能是**监视多个文件描述符**（在网络编程中，文件描述符通常代表一个socket连接），**直到其中一个文件描述符准备好进行某种IO操作（如读或写）为止。**使用select模型的**优点是跨平台性好**，基本上所有的操作系统都支持。但是它有一些明显的**缺点，如单个进程能够监视的文件描述符数量有限（通常是1024），处理效率较低**（每次调用select都需要遍历所有的文件描述符），以及它不能随着连接数的增加而线性扩展。
2. **poll模型**：**poll模型和select模型非常相似，但它没有最大文件描述符数量的限制**。和select一样，poll每次调用时也需要遍历所有的文件描述符，同样不能随着连接数的增加而线性扩展。
3. **epoll模型**：这是一个在Linux 2.6及以后版本中引入的新型IO多路复用模型。与select和poll相比，epoll在处理大量并发连接时更高效。它默认使用了一个事件驱动的方式（ET），**以红黑树作为底层的数据结构**，只有当某个文件描述符准备好进行IO操作时，它才会将这个文件描述符添加到就绪列表中，这避免了遍历所有文件描述符的开销。另外，epoll没有最大文件描述符数量的限制，因此它可以处理更多的并发连接。

每种模型都有其优点和缺点，选择哪种模型取决于你的具体应用和环境。

# epoll/select/poll的区别：
都是多路复用I/O事件监控的机制
**Select:** 将所有需要监控的文件描述符集传递给内核，然后内核在返回之前将它们逐个检查。
缺点：fd_set是unsigned long，1024个；
      每次传入所有监听集合
      每次遍历所有集合
**Poll:** 使用一个包含文件描述符及其相关事件的结构体数组，传递给内核。内核检查这些文件描述符的状态，并返回哪些文件描述符有事件发生。
优点：解决了select1024个限制，文件描述符数组可以动态调整大小
缺点：另两个问题依旧存在
**Epoll：** 创建一个 epoll 实例，将文件描述符和其感兴趣的事件添加到 epoll 实例中。每次只需要传入需要操作个一个fd
Epoll_create 创建
Epoll_ctl 添加/删除fd
Epoll_wait 等待就绪，返回所有已处理fd
![image](https://github.com/FelixQLL/InterviewRecord/assets/28554261/f108fc77-e629-4c4c-8d92-dc43d585ba1f)

# 为什么epoll在高并发的时候性能更好：
不需要重复传递文件描述符集：采用了注册和等待分离的模型。文件描述符的监视是在 epoll_ctl 阶段完成的，通常在初始化时执行。之后，应用程序只需调用 epoll_wait，内核已经知道需要监视哪些文件描述符，从而减少了在用户态和内核态之间的重复数据传递。
更高效的事件通知：epoll 维护一个事件列表，只返回那些实际发生了事件的文件描述符。epoll_wait 只会返回那些状态发生变化的描述符，因此其时间复杂度近似为 O(1)

# 在C++中为什么需要深拷贝，浅拷贝会存在哪些问题？
浅拷贝可能带来以下问题：

- **双重释放**：当原始对象和拷贝对象生命周期结束时，它们的析构函数可能都会尝试释放同一个内存块，导致运行时错误。
- **数据竞争**：两个对象操作相同的资源可能导致数据不一致。
- **野指针**：一个对象释放了共享内存后，另一个对象就持有了一个野指针，继续访问该内存区域会引发未定义行为。

深拷贝解决了浅拷贝的以下问题：

- **避免双重释放**：每个对象负责其自己的资源释放，因此不会出现双重释放问题。
- **避免数据竞争和野指针**：由于每个对象都有自己的数据副本，它们互不干扰。

# 时间复杂度和空间复杂度的定义？时间换空间&空间换时间的例子有哪些
时间复杂度是算法运行所需的时间量度，通常用大 O 表示，表示算法执行步骤数目与输入规模之间的关系。时间复杂度描述了算法运行时间随着输入规模增长时的增长趋势。

空间复杂度是算法在运行过程中所需的存储空间量度，同样用大 O 表示，表示算法运行所需的额外存储空间与输入规模之间的关系。空间复杂度描述了算法运行所需的额外存储空间随着输入规模增长时的增长趋势。

"时间换空间"和"空间换时间"是指在设计算法时，可以根据具体情况选择使用更多的时间来节省空间，或者使用更多的空间来节省时间。以下是一些时间换空间和空间换时间的例子：

1. 时间换空间：缓存技术就是典型的时间换空间策略。通过将计算结果缓存起来，下次再遇到相同输入时可以直接返回缓存的结果，省去重复计算时间，但需要占用额外的空间存储缓存结果。
2. 空间换时间：排序算法中的归并排序和快速排序，虽然时间复杂度较低，但需要额外的空间来存储中间结果，属于典型的空间换时间策略。
3. 时间换空间：动态规划算法中常使用时间换空间策略，通过保存中间计算结果来避免重复计算，提高算法效率。
4. 空间换时间：哈希表（Hash Table）是一种典型的空间换时间的数据结构，通过消耗额外的空间来实现常量级别的查找、插入和删除操作。

# 讲一讲C++中的原子操作有那些？
在C++中，原子操作是由 `<atomic>` 头文件提供的一组操作和类型，它们确保了在多线程环境中对共享数据的修改是不可分割的，即这些操作在执行过程中不会被其他线程打断。原子操作主要用于实现无锁（lock-free）编程，允许多个线程安全地并发访问和修改数据。

`std::atomic` 是C++11引入的一个模板类，用来封装任意类型（满足TriviallyCopyable）的值，并且保证对这些值的操作是原子的。以下是一些常见的原子操作：
1. `store`：将值写入原子对象。
2. `load`：从原子对象读取值。
3. `exchange`：替换原子对象的值，并返回该对象之前的值。
4. `compare_exchange_weak` / `compare_exchange_strong`：比较原子对象的值，并在相等时替换为新值。
5. `fetch_add` / `fetch_sub`：对原子对象进行加/减操作，并返回操作前的值。
6. `fetch_and` / `fetch_or` / `fetch_xor`：对原子对象进行位与/位或/位异或操作，并返回操作前的值。
7. `++` / `--`：原子地递增或递减对象的值。

原子操作还包括一些内存顺序（memory order）的概念，如 `memory_order_relaxed`, `memory_order_consume`, `memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`, `memory_order_seq_cst`。这些内存顺序用于控制操作的执行顺序，以及如何处理编译器和处理器级别的优化。

# 二叉树和链表的区别
1. 结构：
   - 链表是由节点顺序连接而成的线性数据结构，每个节点包含数据域和指向下一个节点的指针。
   - 二叉树是一种树状结构，每个节点最多有两个子节点，分别为左子节点和右子节点。
2. 存储方式：
   - 链表的节点在内存中是按顺序存储的，通过指针进行连接。
   - 二叉树的节点在内存中可以采用链式存储（使用指针连接）或者数组存储（通过计算索引实现）。
3. 操作效率：
   - 在链表中，插入和删除操作的时间复杂度为 O(1)，查找操作的时间复杂度为 O(n)。
   - 在二叉树中，对于平衡二叉搜索树，插入、查找、删除等操作的时间复杂度为 O(log n)。
4. 应用场景：
   - 链表适合动态管理数据集合，特别是频繁需要插入和删除操作的场景。
   - 二叉树适合用于搜索、排序等需要快速查找的应用，如二叉搜索树用于快速查找。

# 数组和链表的区别、适用场景
1. 数组：
- 数组是一种线性数据结构，元素在内存中连续存储。
- 数组具有固定的大小，在创建时需要指定大小。
- 可以通过索引直接访问数组中的元素，时间复杂度为 O(1)。
- 插入和删除元素时，需要移动其他元素来保持连续性，时间复杂度为 O(n)。
- 适合用于元素个数固定、对随机访问要求较高的场景。

1. 链表：
- 链表是一种非连续的线性数据结构，通过指针将元素串联在一起。
- 链表的大小可以动态调整，不需要预先指定大小。
- 链表插入和删除元素的操作简单，时间复杂度为 O(1)。
- 链表不能通过索引直接访问元素，需要从头节点开始遍历，时间复杂度为 O(n)。
- 分为单向链表、双向链表和循环链表等多种形式，提供了更多的灵活性。
- 适合用于频繁插入和删除操作、对内存空间要求较高或元素个数变化较大的场景。

# POST和GET的主要区别有那些？
1. **语义上的区别**：
   - GET请求通常用于请求服务器发送资源或数据。它意味着获取信息，而不应该引起服务器上任何资源的状态改变。
   - POST请求则用于向服务器提交数据以创建或更新资源。它通常会引起服务器上资源的状态变化或副作用。
2. **数据传输位置**：
   - 在GET请求中，数据附加在URL之后作为查询字符串参数进行发送，形式为`?key1=value1&key2=value2`。
   - POST请求将数据包含在请求体中发送给服务器，这意味着数据不会出现在URL中，适合传输敏感信息或大量数据。
3. **数据大小限制**：
   - GET请求由于数据直接附加在URL后面，因此受到URL长度限制（由浏览器和服务器决定），通常不适合传输大量数据。
   - POST请求没有这样的限制，理论上可以传输更多数据，更适合大量数据的传输。
4. **安全性和隐私**：
   - GET请求中的数据暴露在URL中，可能会被浏览器历史、Web服务器日志等记录下来，因此不适合传输敏感信息。
   - POST请求中的数据在请求体内，不会直接暴露在URL中，相对更安全。
5. **缓存和书签**：
   - GET请求可以被缓存，也可以保存为书签。
   - POST请求不会被缓存，也不能保存为书签。

# 什么是拆包和粘包？
在网络通信中，拆包指的是将一个完整的数据包拆分成多个小包发送，而粘包则是将多个小包合并成一个完整的数据包接收。

拆包和粘包常常出现在基于流传输协议（如TCP）的网络通信中。由于TCP是面向流的协议，发送方可以将数据按照任意大小的数据块划分为多个段发送，接收方也可能一次性接收到多个数据段，从而导致拆包和粘包问题。

拆包问题会导致接收方无法正确解析数据，因为一个完整的数据包被分割成了多个部分；而粘包问题则会使接收方难以区分多个数据包的边界，造成数据解析错误。

为避免拆包和粘包问题，通常可采用以下方法：

1. 在数据包中增加长度字段，让接收方根据长度字段来解析数据包。
2. 使用分隔符或者特殊标记来标识数据包的边界。
3. 对数据包进行序列化和反序列化，确保数据的完整性和正确性。
4. 应用层协议设计时考虑消息头和消息体的格式，规范数据的传输方式。

通过以上方法，可以有效地解决拆包和粘包问题，确保数据在网络传输中能够正确解析和处理。

# 内存泄漏排查：
安装gperftools
Gperftools，修改程序，在main函数添加 ProfilerStart和ProfilerStop
Kill 程序 开启和结束
生成svg，生成火焰图
